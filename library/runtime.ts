// This file is generated from source/runtime.ts
// To regenerate, run `npm run prepare`
const runtime = "namespace runtime {\n  export interface Location {\n    line: number;\n    column: number;\n    offset: number;\n  }\n\n  export interface LocationRange {\n    source?: string | GrammarLocation;\n    start: Location;\n    end: Location;\n  }\n\n  export interface Range {\n    source?: string | GrammarLocation;\n    start: number;\n    end: number;\n  }\n\n  export class GrammarLocation {\n    source: string | GrammarLocation;\n    start: Location;\n\n    constructor(source: string | GrammarLocation, start: Location) {\n      this.source = source;\n      this.start = start;\n    }\n\n    toString(): string {\n      return String(this.source);\n    }\n\n    offset(loc: Location): Location {\n      return {\n        line: loc.line + this.start.line - 1,\n        column: (loc.line === 1)\n          ? loc.column + this.start.column - 1\n          : loc.column,\n        offset: loc.offset + this.start.offset,\n      };\n    }\n\n    static offsetStart(range: LocationRange): Location {\n      if (range.source instanceof GrammarLocation) {\n        return range.source.offset(range.start);\n      }\n      return range.start;\n    }\n\n    static offsetEnd(range: LocationRange): Location {\n      if (range.source instanceof GrammarLocation) {\n        return range.source.offset(range.end);\n      }\n      return range.end;\n    }\n  }\n\n  export function padEnd(str: string, targetLength: number, padString: string) {\n    padString = padString || \" \";\n    if (str.length > targetLength) { return str; }\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n  }\n\n  export interface SourceText {\n    source: any;\n    text: string;\n  }\n\n  function hex(ch: string): string {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  export interface Expectation {\n    type: \"literal\" | \"class\" | \"any\" | \"end\" | \"pattern\" | \"other\";\n    value: string;\n  }\n\n  function escape(s: string): string {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g, function (ch) {\n        return \"\\\\x0\" + hex(ch);\n      })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n        return \"\\\\x\" + hex(ch);\n      });\n }\n\n  export class ParseFailure {\n  }\n\n  export class ParseOptions {\n    currentPosition?: number;\n    silentFails?: number;\n    maxFailExpected?: Expectation[];\n    grammarSource?: string | GrammarLocation;\n    library?: boolean;\n    startRule?: string;\n    [index: string]: unknown;\n  }\n\n  export type Result<T> = Failure | Success<T>;\n\n  export interface Failure {\n    success: false;\n    expectations: Expectation[];\n    remainder: string;\n  }\n\n  export interface Success<T> {\n    success: true;\n    value: T;\n    remainder: string;\n  }\n\n  export function isFailure(r: Result<unknown>): r is Failure {\n    return !r.success;\n  }\n\n  function getLine(input: string, offset: number) {\n    let line = 1;\n\n    for (let i = 0; i < offset; i++) {\n      if (input[i] === \"\\r\") {\n        if (input[i + 1] === \"\\n\") {\n          i++;\n        }\n\n        line++;\n      } else if (input[i] === \"\\n\") {\n        line++;\n      }\n    }\n\n    return line;\n  }\n\n  function getColumn(input: string, offset: number) {\n    let column = 1;\n\n    for (let i = offset; i > 0; i--) {\n      if ([\"\\n\", \"\\r\"].includes(input[i-1])) {\n        break;\n      }\n\n      column++;\n    }\n\n    return column;\n  }\n\n  export function getLocation(source: string | GrammarLocation | undefined, input: string, start: string, remainder: string): runtime.LocationRange {\n    return {\n      source,\n      start: {\n        offset: input.length - start.length,\n        line: getLine(input, input.length - start.length),\n        column: getColumn(input, input.length - start.length)\n      },\n      end: {\n        offset: input.length - remainder.length,\n        line: getLine(input, input.length - remainder.length),\n        column: getColumn(input, input.length - remainder.length)\n      },\n    }\n  }\n\n  export function getRange(source: string | GrammarLocation | undefined, input: string, start: string, remainder: string) {\n    return {\n      source,\n      start: input.length - start.length,\n      end: input.length - remainder.length\n    }\n  }\n\n  export function getText(start: string, remainder: string) {\n    return start.slice(0, remainder.length > 0 ? -remainder.length : undefined)\n  }\n}\n\nexport class SyntaxError extends Error {\n  expected: runtime.Expectation[];\n  found: string | null;\n  location: runtime.LocationRange;\n\n  constructor(\n    expected: runtime.Expectation[],\n    found: string | null,\n    location: runtime.LocationRange,\n  ) {\n    super(SyntaxError.formatMessage(expected, found));\n    this.name = \"SyntaxError\";\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n  }\n\n  static formatMessage(expected: runtime.Expectation[], found: string | null): string {\n    function describeExpected(expected: runtime.Expectation[]): string {\n      const descriptions = expected.map(e => e.value);\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        let j = 1;\n        for (let i = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") +\n            \", or \" +\n            descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found: string | null): string {\n      return found\n        ? JSON.stringify(found)\n        : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" +\n      describeFound(found) + \" found.\";\n  }\n\n  format = (sources: runtime.SourceText[]) => {\n    var str = \"Error: \" + this.message;\n\n    if (this.location) {\n      var src = null;\n      var k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].source === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      var s = this.location.start;\n      var offset_s = (this.location.source instanceof runtime.GrammarLocation)\n        ? this.location.source.offset(s)\n        : s;\n      var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n      if (src) {\n        var e = this.location.end;\n        var filler = runtime.padEnd(\"\", offset_s.line.toString().length, ' ');\n        var line = src[s.line - 1];\n        var last = s.line === e.line ? e.column : line.length + 1;\n        var hatLen = (last - s.column) || 1;\n        str += \"\\n --> \" + loc + \"\\n\"\n            + filler + \" |\\n\"\n            + offset_s.line + \" | \" + line + \"\\n\"\n            + filler + \" | \" + runtime.padEnd(\"\", s.column - 1, ' ')\n            + runtime.padEnd(\"\", hatLen, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  }\n}\n";
export default runtime;